//! ZK proof structures for shielded transactions.
//!
//! Proofs are generated by the browser wallet using snarkjs and Circom circuits.
//! This module provides serialization for storing proofs in transactions.

use serde::{Deserialize, Serialize};

use super::snarkjs::{CircomVerifyingKey, SnarkJsProof, parse_proof_struct};

/// Verification keys for Circom circuits.
///
/// These are loaded from the JSON verification keys exported by snarkjs.
pub struct CircomVerifyingParams {
    /// Spend circuit verification key.
    pub spend_vk: CircomVerifyingKey,
    /// Output circuit verification key.
    pub output_vk: CircomVerifyingKey,
}

impl CircomVerifyingParams {
    /// Load verification keys from JSON files.
    pub fn from_files(spend_vkey_path: &str, output_vkey_path: &str) -> Result<Self, String> {
        let spend_vk = CircomVerifyingKey::from_file(spend_vkey_path)?;
        let output_vk = CircomVerifyingKey::from_file(output_vkey_path)?;
        Ok(Self { spend_vk, output_vk })
    }

    /// Load from JSON strings.
    pub fn from_json(spend_vkey_json: &str, output_vkey_json: &str) -> Result<Self, String> {
        let spend_vk = CircomVerifyingKey::from_json(spend_vkey_json)?;
        let output_vk = CircomVerifyingKey::from_json(output_vkey_json)?;
        Ok(Self { spend_vk, output_vk })
    }
}

/// A serializable zk-SNARK proof.
///
/// This stores proofs generated by snarkjs in the browser.
/// The proof is stored as JSON for compatibility with snarkjs format.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ZkProof {
    /// The snarkjs proof structure.
    #[serde(flatten)]
    pub proof: SnarkJsProof,
}

impl ZkProof {
    /// Create from a snarkjs proof.
    pub fn from_snarkjs(proof: SnarkJsProof) -> Self {
        Self { proof }
    }

    /// Create from JSON string.
    pub fn from_json(json: &str) -> Result<Self, String> {
        serde_json::from_str(json)
            .map_err(|e| format!("Invalid proof JSON: {}", e))
    }

    /// Serialize to JSON string.
    pub fn to_json(&self) -> String {
        serde_json::to_string(&self.proof).unwrap_or_default()
    }

    /// Get the size of the proof in bytes (JSON serialized).
    pub fn size(&self) -> usize {
        self.to_json().len()
    }

    /// Verify this proof against public inputs using a Circom verification key.
    pub fn verify(
        &self,
        vk: &super::snarkjs::CircomVerifyingKey,
        public_inputs: &[ark_bn254::Fr],
    ) -> bool {
        match parse_proof_struct(&self.proof) {
            Ok(proof) => super::snarkjs::verify_proof(vk, &proof, public_inputs),
            Err(_) => false,
        }
    }
}

/// Convert spend public inputs from bytes to field elements.
///
/// Spend circuit public inputs:
/// - merkle_root: Tree root as a field element
/// - nullifier: Nullifier as a field element
/// - value_commitment_hash: Hash of value commitment as a field element
pub fn spend_bytes_to_public_inputs(
    merkle_root: &[u8; 32],
    nullifier: &[u8; 32],
    value_commitment_hash: &[u8; 32],
) -> Vec<ark_bn254::Fr> {
    use super::poseidon::bytes32_to_field;
    vec![
        bytes32_to_field(merkle_root),
        bytes32_to_field(nullifier),
        bytes32_to_field(value_commitment_hash),
    ]
}

/// Convert output public inputs from bytes to field elements.
///
/// Output circuit public inputs:
/// - note_commitment: Note commitment as a field element
/// - value_commitment_hash: Hash of value commitment as a field element
pub fn output_bytes_to_public_inputs(
    note_commitment: &[u8; 32],
    value_commitment_hash: &[u8; 32],
) -> Vec<ark_bn254::Fr> {
    use super::poseidon::bytes32_to_field;
    vec![
        bytes32_to_field(note_commitment),
        bytes32_to_field(value_commitment_hash),
    ]
}

/// Alias for backwards compatibility.
pub fn bytes_to_public_inputs(
    merkle_root: &[u8; 32],
    nullifier: &[u8; 32],
    value_commitment_hash: &[u8; 32],
) -> Vec<ark_bn254::Fr> {
    spend_bytes_to_public_inputs(merkle_root, nullifier, value_commitment_hash)
}

/// Verify a spend proof.
pub fn verify_spend_proof(
    proof: &ZkProof,
    public_inputs: &[ark_bn254::Fr],
    verifying_params: &CircomVerifyingParams,
) -> bool {
    proof.verify(&verifying_params.spend_vk, public_inputs)
}

/// Verify an output proof.
pub fn verify_output_proof(
    proof: &ZkProof,
    public_inputs: &[ark_bn254::Fr],
    verifying_params: &CircomVerifyingParams,
) -> bool {
    proof.verify(&verifying_params.output_vk, public_inputs)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_zkproof_json_roundtrip() {
        let proof_json = r#"{
            "pi_a": ["1", "2", "1"],
            "pi_b": [["3", "4"], ["5", "6"], ["1", "0"]],
            "pi_c": ["7", "8", "1"],
            "protocol": "groth16",
            "curve": "bn128"
        }"#;

        let proof = ZkProof::from_json(proof_json).unwrap();
        assert_eq!(proof.proof.protocol, "groth16");
        assert_eq!(proof.proof.curve, "bn128");
    }
}
