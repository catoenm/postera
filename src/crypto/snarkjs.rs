//! SnarkJS proof verification for Circom-generated proofs.
//!
//! This module provides verification of Groth16 proofs generated by snarkjs
//! using Circom circuits. It parses the JSON formats used by snarkjs and
//! converts them to arkworks types for verification.
//!
//! The browser wallet generates proofs using snarkjs, and this module
//! allows the Rust node to verify those proofs.

use ark_bn254::{Bn254, Fq, Fq2, Fr, G1Affine, G1Projective, G2Affine, G2Projective};
use ark_groth16::{prepare_verifying_key, Groth16, PreparedVerifyingKey, Proof, VerifyingKey};
use ark_snark::SNARK;
use serde::{Deserialize, Serialize};
use std::str::FromStr;

/// SnarkJS verification key format (JSON).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnarkJsVerifyingKey {
    pub protocol: String,
    pub curve: String,
    #[serde(rename = "nPublic")]
    pub n_public: usize,
    pub vk_alpha_1: Vec<String>,
    pub vk_beta_2: Vec<Vec<String>>,
    pub vk_gamma_2: Vec<Vec<String>>,
    pub vk_delta_2: Vec<Vec<String>>,
    #[serde(rename = "IC")]
    pub ic: Vec<Vec<String>>,
}

/// SnarkJS proof format (JSON).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnarkJsProof {
    pub pi_a: Vec<String>,
    pub pi_b: Vec<Vec<String>>,
    pub pi_c: Vec<String>,
    pub protocol: String,
    pub curve: String,
}

/// Parsed verification key ready for use.
pub struct CircomVerifyingKey {
    pub vk: VerifyingKey<Bn254>,
    pub pvk: PreparedVerifyingKey<Bn254>,
    pub n_public: usize,
}

/// Parse a decimal string to Fq (base field element).
fn parse_fq(s: &str) -> Result<Fq, String> {
    Fq::from_str(s).map_err(|_| format!("Invalid Fq: {}", s))
}

/// Parse a decimal string to Fr (scalar field element).
fn parse_fr(s: &str) -> Result<Fr, String> {
    Fr::from_str(s).map_err(|_| format!("Invalid Fr: {}", s))
}

/// Parse a G1 point from snarkjs format [x, y, z] (projective).
fn parse_g1(coords: &[String]) -> Result<G1Affine, String> {
    if coords.len() != 3 {
        return Err("G1 point must have 3 coordinates".to_string());
    }

    let x = parse_fq(&coords[0])?;
    let y = parse_fq(&coords[1])?;
    let z = parse_fq(&coords[2])?;

    // Convert from projective to affine
    let proj = G1Projective::new(x, y, z);
    Ok(proj.into())
}

/// Parse a G2 point from snarkjs format [[x0, x1], [y0, y1], [z0, z1]] (projective).
fn parse_g2(coords: &[Vec<String>]) -> Result<G2Affine, String> {
    if coords.len() != 3 {
        return Err("G2 point must have 3 coordinate pairs".to_string());
    }

    let x = Fq2::new(parse_fq(&coords[0][0])?, parse_fq(&coords[0][1])?);
    let y = Fq2::new(parse_fq(&coords[1][0])?, parse_fq(&coords[1][1])?);
    let z = Fq2::new(parse_fq(&coords[2][0])?, parse_fq(&coords[2][1])?);

    let proj = G2Projective::new(x, y, z);
    Ok(proj.into())
}

impl CircomVerifyingKey {
    /// Load a verification key from snarkjs JSON format.
    pub fn from_json(json: &str) -> Result<Self, String> {
        let vk_json: SnarkJsVerifyingKey =
            serde_json::from_str(json).map_err(|e| format!("Invalid JSON: {}", e))?;

        Self::from_snarkjs(&vk_json)
    }

    /// Load a verification key from a parsed snarkjs struct.
    pub fn from_snarkjs(vk_json: &SnarkJsVerifyingKey) -> Result<Self, String> {
        if vk_json.protocol != "groth16" {
            return Err(format!("Unsupported protocol: {}", vk_json.protocol));
        }
        if vk_json.curve != "bn128" {
            return Err(format!("Unsupported curve: {}", vk_json.curve));
        }

        let alpha_g1 = parse_g1(&vk_json.vk_alpha_1)?;
        let beta_g2 = parse_g2(&vk_json.vk_beta_2)?;
        let gamma_g2 = parse_g2(&vk_json.vk_gamma_2)?;
        let delta_g2 = parse_g2(&vk_json.vk_delta_2)?;

        let gamma_abc_g1: Vec<G1Affine> = vk_json.ic
            .iter()
            .map(|ic| parse_g1(ic))
            .collect::<Result<Vec<_>, _>>()?;

        let vk = VerifyingKey {
            alpha_g1,
            beta_g2,
            gamma_g2,
            delta_g2,
            gamma_abc_g1,
        };

        let pvk = prepare_verifying_key(&vk);

        Ok(Self {
            vk,
            pvk,
            n_public: vk_json.n_public,
        })
    }

    /// Load from a JSON file.
    pub fn from_file(path: &str) -> Result<Self, String> {
        let json = std::fs::read_to_string(path)
            .map_err(|e| format!("Failed to read file: {}", e))?;
        Self::from_json(&json)
    }
}

/// Parse a snarkjs proof from JSON.
pub fn parse_proof(json: &str) -> Result<Proof<Bn254>, String> {
    let proof_json: SnarkJsProof =
        serde_json::from_str(json).map_err(|e| format!("Invalid JSON: {}", e))?;

    parse_proof_struct(&proof_json)
}

/// Parse a snarkjs proof from a parsed struct.
pub fn parse_proof_struct(proof_json: &SnarkJsProof) -> Result<Proof<Bn254>, String> {
    if proof_json.protocol != "groth16" {
        return Err(format!("Unsupported protocol: {}", proof_json.protocol));
    }

    let a = parse_g1(&proof_json.pi_a)?;
    let b = parse_g2(&proof_json.pi_b)?;
    let c = parse_g1(&proof_json.pi_c)?;

    Ok(Proof { a, b, c })
}

/// Parse public signals from snarkjs format (array of decimal strings).
pub fn parse_public_signals(signals: &[String]) -> Result<Vec<Fr>, String> {
    signals
        .iter()
        .map(|s| parse_fr(s))
        .collect()
}

/// Verify a snarkjs proof against public inputs.
pub fn verify_proof(
    vk: &CircomVerifyingKey,
    proof: &Proof<Bn254>,
    public_inputs: &[Fr],
) -> bool {
    Groth16::<Bn254>::verify_with_processed_vk(&vk.pvk, public_inputs, proof)
        .unwrap_or(false)
}

/// Verify a snarkjs proof from JSON strings.
pub fn verify_proof_json(
    vk: &CircomVerifyingKey,
    proof_json: &str,
    public_signals: &[String],
) -> Result<bool, String> {
    let proof = parse_proof(proof_json)?;
    let inputs = parse_public_signals(public_signals)?;
    Ok(verify_proof(vk, &proof, &inputs))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_load_output_vkey() {
        let vk = CircomVerifyingKey::from_file("circuits/build/output_vkey.json");
        assert!(vk.is_ok(), "Failed to load output vkey: {:?}", vk.err());
        let vk = vk.unwrap();
        assert_eq!(vk.n_public, 2);
    }

    #[test]
    fn test_load_spend_vkey() {
        let vk = CircomVerifyingKey::from_file("circuits/build/spend_vkey.json");
        assert!(vk.is_ok(), "Failed to load spend vkey: {:?}", vk.err());
        let vk = vk.unwrap();
        assert_eq!(vk.n_public, 3);
    }
}
